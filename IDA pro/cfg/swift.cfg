
// This configuration file is used by the swift plugin, which improves analysis
// of the files written using the Swift programming language.


// The demangler setting.
// The swift plugin uses libSwiftDemangle to demangle Swift names.
// Note that IDA already had a built-in swift demangler, but it was becoming difficult
// to maintain. The long-term goal of this plugin is to fully deprecate IDA's
// custom swift demangler in favor of libSwiftDemangle.
//
// However, the new approach still hasn't been fully integrated into IDA,
// so there may be times when IDA's old swift demangler produces more
// desirable results.
//
// Set this option to NO if you prefer the names generated by the old swift demangler.
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-d input_file
//   to enable   ida -Oswift:+d input_file

#define DISABLE 0 // disable the plugin
#define ENABLE  1 // enable the plugin
#define AUTO    2 // enable the plugin if the input file has properties of a Swift file
DEMANGLER_ENABLED = AUTO

// Path to libSwiftDemangle.
// If not specified, the plugin will use the libSwiftDemangle library that is shipped with IDA.

DEMANGLER_PATH = "";

// The Swift runtime keeps a metadata record for every type used in a program.
// This option forces the plugin to present the metadata in a nice way.
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-m input_file
//   to enable   ida -Oswift:+m input_file

METADATA_MARKUP = YES

// Import enumeration types.
// ATM the plugin creates only simple enumerations (without associated values).
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-e input_file
//   to enable   ida -Oswift:+e input_file

SWIFT_ENUMS = YES


// Import structure types.
// The plugin creates a structure when it knows types of all fields.
// However, if a structure contains a field without the description in the
// binary file or of the unsupported built-in type, the plugin cannot create a
// type for the structure.
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-s input_file
//   to enable   ida -Oswift:+s input_file

SWIFT_STRUCTS = YES


// Set variable types based on mangled names.
// The plugin analyzes all item (code or data) names.
// If the name looks like a variable name, then the plugin sets
// the variable type using the info encoded in the mangled name.
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-v input_file
//   to enable   ida -Oswift:+v input_file

SWIFT_APPLY_VARIABLE_TYPES = YES


// Set function prototypes based on mangled names.
// The plugin analyzes all item (code or data) names.
// If the name looks like a function name, then the plugin sets
// the function type using the info encoded in the mangled name.
// Alternatively, it is possible to use the command line:
//   to disable  ida -Oswift:-f input_file
//   to enable   ida -Oswift:+f input_file

SWIFT_APPLY_FUNCTION_TYPES = YES


// List of modules to map types of these modules to the C-types.
//
// The module names are delimited with ';'. After '=>' is the prefix to use
// when looking for the C-type.
//
// For example: '__C.=>' means that __C.NSString will be mapped to NSString
// ('=>' may be ommitted in this case),
// 'Builtin.=>Builtin::' means that Builtin.Job will be mapped to Builtin::Job
//
// The plugin cannot import a structure with an unknown field type.
// The user can fix this by creating the type himself, adding a suitable
// mapping, and reloading the plugin.

CTYPE_MAPPING = "__C.;Builtin.=>Builtin::";
